<!DOCTYPE html>
<html>
<head>
  <title>File Reactive-Streams.html in D:\git\RxDocs\topics</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<h1 id="reactive-streams-rxjava">Reactive Streams + RxJava</h1>
<p><a href="https://github.com/reactive-streams/reactive-streams-jvm/">Reactive Streams</a> has been a <a href="https://medium.com/@viktorklang/reactive-streams-1-0-0-interview-faaca2c00bec">collaborative effort</a> to standardize the protocol for asynchronous streams on the JVM. The RxJava team was <a href="https://github.com/reactive-streams/reactive-streams-jvm/graphs/contributors">part of the effort</a> from the beginning and supports the use of Reactive Streams APIs and eventually the <a href="http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/013641.html">Java 9 Flow APIs</a> which are <a href="https://github.com/reactive-streams/reactive-streams-jvm/issues/195">resulting from the success of the Reactive Stream effort</a>.</p>
<h2 id="how-does-this-relate-to-rxjava-itself-">How does this relate to RxJava itself?</h2>
<h4 id="rxjava-1-x">RxJava 1.x</h4>
<p>Currently RxJava 1.x does not directly implement the Reactive Streams APIs. This is due to RxJava 1.x already existing and not being able to break public APIs. It does however comply semantically with the non-blocking &quot;reactive pull&quot; approach to backpressure and flow control and thus can use a bridge between types. The <a href="https://github.com/ReactiveX/RxJavaReactiveStreams">RxJavaReactiveStreams module</a> bridges between the RxJava 1.x types and Reactive Streams types for interop between Reactive Streams implementations and passes the Reactive Streams <a href="https://github.com/ReactiveX/RxJavaReactiveStreams/blob/0.x/rxjava-reactive-streams/build.gradle#L8">TCK compliance tests</a>.</p>
<p>Its API looks like this:</p>
<pre><code class="lang-java">package rx;

import org.reactivestreams.Publisher;

public abstract class RxReactiveStreams {

    public static &lt;T&gt; Publisher&lt;T&gt; toPublisher(Observable&lt;T&gt; observable) { … }

    public static &lt;T&gt; Observable&lt;T&gt; toObservable(Publisher&lt;T&gt; publisher) { … }

}
</code></pre>
<h4 id="rxjava-2-x">RxJava 2.x</h4>
<p><a href="https://github.com/ReactiveX/RxJava/issues/2450">RxJava 2.x</a> will target Reactive Streams APIs directly for Java 8+. The plan is to also support Java 9 <code>j.u.c.Flow</code> types by leveraging new Java multi-versioned jars to support this when using RxJava 2.x in Java 9 while still working on Java 8. </p>
<p>RxJava 2 will truly be &quot;Reactive Extensions&quot; now that there is an interface to extend. RxJava 1 didn&#39;t have a base interface or contract to extend so had to define it from scratch. RxJava 2 intends on being a high performing, battle-tested, lightweight (single dependency on Reactive Streams), non-opinionated implementation of Reactive Streams and <code>j.u.c.Flow</code> that provides a library of higher-order functions with parameterized concurrency. </p>
<h2 id="public-apis-of-libraries">Public APIs of Libraries</h2>
<p>A strong area of value for Reactive Streams is public APIs exposed in libraries. Following is some guidance and recommendation on how to use both Reactive Streams and RxJava in creating reactive libraries while decoupling the concrete implementations. </p>
<h3 id="pros-of-exposing-reactive-stream-apis-instead-of-rxjava">Pros of Exposing Reactive Stream APIs instead of RxJava</h3>
<ul>
<li>Lightweight: Very lightweight dependency on interfaces without any concrete implementations. This keeps dependency graphs and bytesize small.</li>
<li>Future Proof: Since the Reactive Stream API is so simple, was collaboratively defined and is <a href="https://github.com/reactive-streams/reactive-streams-jvm/issues/195">becoming part</a> of <a href="http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/013641.html">JDK 9</a> it is a future proof API for exposing async access to data. The <a href="http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/Flow.html"><code>j.u.c.Flow</code> APIs</a> of JDK 9 match the APIs of Reactive Streams so any types that implement the Reactive Streams <code>Publisher</code> will also be able to implement the <code>Flow.Publisher</code> type. </li>
<li>Interop: An API exposed with Reactive Streams types can easily be consumed by any implementation such as RxJava, Akka Streams and Reactor.</li>
</ul>
<h3 id="cons-of-exposing-reactive-stream-apis-instead-of-rxjava">Cons of Exposing Reactive Stream APIs instead of RxJava</h3>
<ul>
<li><p>A Reactive Stream <code>Publisher</code> is not very useful by itself. Without higher-order functions like <code>flatMap</code> it is just a better callback. This means that consumption of a <code>Publisher</code> will almost always need to be converted or wrapped into a Reactive Stream implementation. This can be verbose and awkward to always be wrapping <code>Publisher</code> APIs into a concrete implementation. If the JVM supported extension methods this would be elegant, but since it doesn&#39;t it is explicit and verbose. </p>
<p>  Specifically the Reactive Streams and Flow <code>Publisher</code> interfaces do not provide any implementations of operators like <code>flatMap</code>, <code>merge</code>, <code>filter</code>, <code>take</code>, <code>zip</code> and the many others used to compose and transform async streams. A <code>Publisher</code> can only be subscribed to. A concrete implementation such as RxJava is needed to provide composition. </p>
</li>
<li>The Reactive Streams specification and binary artifacts do not provide a concrete implementation of <code>Publisher</code>. Generally a library will need or want capabilities provides by RxJava, Akka Streams, etc for its internal use or just to produce a valid <code>Publisher</code> that supports backpressure semantics (which are non-trivial to implement correctly).</li>
</ul>
<h3 id="recommended-approach">Recommended Approach</h3>
<p>Now that Reactive Streams has achieved 1.0 we recommend using it for core APIs that are intended for interop. This will allow embracing asynchronous stream semantics without a hard dependency on any single implementation. This means a consumer of the API can then choose RxJava 1.x, RxJava 2.x, Akka Streams, Reactor or other stream composition libraries as suits them best. It also provides better future proofing, for example as RxJava moves from 1.x to 2.x. </p>
<p>However, to limit the cons listed above, we also recommend making it easy for consumption without developers needing to explicitly wrap the APIs with their composition library of choice. For this reason we recommend providing wrapper modules for popular Reactive Stream implementations on top of the core API, otherwise your customers will each need to do this themselves. </p>
<p>Note that if Java offered extension methods this approach wouldn&#39;t be needed, but until Java offers that (not anytime soon if ever) the following is an approach to achieve the pros and address the cons.</p>
<p>For example, a database driver may have modules such as this:</p>
<p>// core library exposing Reactive Stream Publisher APIs</p>
<ul>
<li>async-database-driver </li>
</ul>
<p>// integration jars wrapped with concrete implementations</p>
<ul>
<li>async-database-driver-rxjava1</li>
<li>async-database-driver-rxjava2</li>
<li>async-database-driver-akka-stream</li>
</ul>
<p>The &quot;core&quot; may expose an API like this:</p>
<pre><code class="lang-java">package com.database.driver;

public class Database {
   public org.reactivestreams.Publisher getValue(String key);
}
</code></pre>
<p>The RxJava 1.x wrapper could then be a separate module that provides RxJava specific APIs like this:</p>
<pre><code class="lang-java">package com.database.driver.rxjava1;

public class Database {
    public rx.Observable getValue(String key);
}
</code></pre>
<p>The core <code>Publisher</code> API can be wrapped as simply as this:</p>
<pre><code class="lang-java">public rx.Observable getValue(String key) {
   return RxReactiveStreams.toObservable(coreDatabase.getValue(key));
}
</code></pre>
<p>The RxJava 2.x wrapper would differ like this (once 2.x is available):</p>
<pre><code class="lang-java">package com.database.driver.rxjava2;

public class Database {
    public io.reactivex.Observable getValue(String key);
}
</code></pre>
<p>The Akka Streams wrapper would in turn look like this:</p>
<pre><code class="lang-java">package com.database.driver.akkastream;

public class Database {
    public akka.stream.javadsl.Source getValue(String key);
}
</code></pre>
<p>A developer could then choose to depend directly on the <code>async-database-driver</code> APIs but most will use one of the wrappers that supports the composition library they have chosen. </p>
<hr>
<p>If something could be clarified further, please help improve this page via discussion at <a href="https://github.com/ReactiveX/RxJava/issues/2917">https://github.com/ReactiveX/RxJava/issues/2917</a></p>
</body>
<html>
